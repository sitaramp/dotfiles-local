"
" Credit https://github.com/statico/dotfiles/blob/master/.vim/vimrc
"
" Mnemonic
" b - buffer; p = project; s = search; h = help

" Janus custominzation
"======================
"<leader>ul underline
":sudoW sudoWrite
"<F4> toggle paste mode
"<leader>u covert the entire word to lowercase
"<leader>l covert the entire word to lowercase
"<leader>tw toggle wrap

" NERDTree
"<leader>n NERDTreeToggle

" Unimpaired
"[b go to the prev buffer
"]b go to the next buffer
"[n go to the prev conflict
"]n go to the next confiict
"[q go to the prev quickix item
"]q go to the next quickfix item

" Fugitive
"<leader>gb maps to :Gblame<CR>
"<leader>gd maps to :Gdiff<CR>
"<leader>gs maps to :Gstatus<CR>
"<leader>gl maps to :Glog<CR>
"<leader>gc maps to :Gcommit<CR>
"<leader>gp maps to :Gpush<CR>

" vim-trailing-whitespace
":FixWhitespace

" Switch between the last two files
nmap <C-e> :e#<CR>
nnoremap <Leader><Leader> <C-^>
"nmap [b   :bprev<CR>
"nmap ]b   :bnext<CR>

" single key acess to Buffers
nmap ;  :Buffers<CR>
nmap \0 :buffers<CR>
nmap \1 :e #1<CR>
nmap \2 :e #2<CR>
nmap \3 :e #3<CR>
nmap \4 :e #4<CR>
nmap \5 :e #5<CR>
nmap \6 :e #6<CR>
nmap \7 :e #7<CR>
nmap \8 :e #8<CR>
nmap \9 :e #9<CR>
"close quickfix window
nmap \x :cclose<CR>
nnoremap <leader>w :w!<CR>
nnoremap <leader>. :bnext<CR>
nnoremap <leader>, :bprev<CR>

" Single key access to files fzf and tags
nmap <leader>b :Buffers<CR>
nmap <leader>t :Files<CR>
"nnoremap <C-t> :Files<CR>
nmap <leader>r :Tags<CR>
nmap <leader>c :Colors<CR>

" Tell ack.vim to use ripgrep instead
let g:ackprg = 'rg --vimgrep --no-heading'

let $FZF_DEFAULT_COMMAND = 'rg --files --follow -g "!{.git,obj}/*" 2>/dev/null'
"command! -bang -nargs=* Rg
  "\ call fzf#vim#grep(
  "\   'rg --column --line-number --no-heading --color=always --smart-case -g "!{*.lock,*-lock.json, *.obj}" '.shellescape(<q-args>), 1,
  "\   <bang>0 ? fzf#vim#with_preview('up:40%')
  "\           : fzf#vim#with_preview('right:50%:hidden', '?'),
  "\   <bang>0)

" fzy file filter
function! FzyCommand(choice_command, vim_command)
  try
    let output = system(a:choice_command . " | fzy ")
  catch /Vim:Interrupt/
    " Swallow errors from ^C, allow redraw! below
  endtry
  redraw!
  if v:shell_error == 0 && !empty(output)
    exec a:vim_command . ' ' . output
  endif
endfunction
nnoremap <leader>e :call FzyCommand("fd ''", ":e")<cr>
nnoremap <leader>v :call FzyCommand("fd ''", ":vs")<cr>
nnoremap <leader>s :call FzyCommand("fd ''", ":sp")<cr>

" fuzzy grep. Use ^c to abort
nnoremap <C-a>     :Rg<cr>
nnoremap <leader>a :Rg<cr>

" Search for word under the cursor in the current directory
" Use \x to close quickfix window 
nnoremap <C-k>     mo:Ack! "\b<cword>\b" <CR>
nnoremap <leader>k mo:Ack! "\b<cword>\b" <CR>
"nnoremap <C-S-k>  mo:Ggrep! "\b<cword>\b" <CR>

"""""""""""""""""""""""""""""""
" Toggle search highlight on off with F5
"""""""""""""""""""""""""""""""""
map  <F5>      :set hls!<bar> set hls?<CR>
imap <F5><Esc> :set hls!<bar> set hls?<CR>
set pastetoggle=<F2>
" Tagbar C++ class outline viewer
nmap <F8> :TagbarToggle<CR>


" SuperTab
let g:SuperTabLongestEnhanced = 1
let g:SuperTabLongestHighlight = 1
au Filetype typescript let b:SuperTabDefaultCompletionType = "<C-x><C-o>"

" Change j,k to act more visually in presence of wrapped lines
" wrapparound line movement
nmap     j gj
nmap     k gk
nnoremap ' `
nnoremap Y y$

" Emacs-like binding in the command line
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
" Emacs-like bindings in insert mode
imap <C-e> <C-o>$
imap <C-a> <C-o>0
inoremap jj <Esc>


" Fix annoyances inthe QuickFix window
autocmd FileType qf setlocal number nolist
autocmd FileType qf wincmd J " Makes sure it's at the bottom of the vim window

set noswapfile
set autowrite
set autoread

" make it possible to edit crontabs in vim.
if $VIM_CRONTAB == "true"
    set nobackup
    set nowritebackup
endif

augroup checktime
  au!
  if !has("gui_running")
    "silent! is necessary,otherwise throws errors when using cmd
    autocmd BufEnter,CursorHold,CursorHoldI * silent! checktime
  endif
augroup END

" These are things that I mistype and want ignored.
nmap Q  <silent>
nmap q: <silent>
nmap K  <silent>
command! Q q
command! W w

" Quitting
" quit all, don't force
map <leader>qq :qa<CR>
" quit all, losing unsaved changes
map <leader>qQ :qa!<CR>
" quit all, after saving all files
map <leader>qs :wqa!<CR>

" tab, spacing, wrapping
set expandtab
set shiftwidth=4
set tabstop=4
set smarttab
set nowrap

" Trim spaces at EOL and retab. I run `:CLEAN` a lot to clean up files.
command! TEOL %s/\s\+$//
command! CLEAN retab | TEOL

"" highlight whitespace errors
""set listchars=tab:▸\ ,eol:¬
""set listchars=tab:▸\ ,trail:·
"highlight NonText guibg=#060606
"highlight Folded  guibg=#0A0A0A guifg=#9090D0
set colorcolumn=80
highlight ColorColumn ctermbg=darkgray

"match ExtraWhitespace /\s\+\%#\@<!$/
"highlight ExtraWhitespace ctermbg=darkgreen guibg=lightgreen
"highlight WhiteSpaceEOL ctermbg=white guibg=white
"let c_space_errors = 1

" enable mouse in normal and visual mode. See help using-mouse
set mouse=nv

" Use Shift + Drag shift + Right Click to copy paste
" Use Shift + Cntrl + v to insert
" To enable Right to paste disable mouse
" set mouse-=a

" The * is the default clipboard + is the selection clipboard
" paste plus clipboard using using "+p
"set clipboard=unamed
set clipboard^=unnamed,unnamedplus
"copy paste to system cliboard by prefixing with <leader>
noremap <leader>y "*y
noremap <leader>p "*p
noremap <leader>Y "+y
noremap <leader>P "+p

"" {{{ automatic paste mode
function! WrapForTmux(s)
  if !exists('$TMUX')
    return a:s
  endif

  let tmux_start = "\<Esc>Ptmux;"
  let tmux_end = "\<Esc>\\"

  return tmux_start . substitute(a:s, "\<Esc>", "\<Esc>\<Esc>", 'g') . tmux_end
endfunction

let &t_SI .= WrapForTmux("\<Esc>[?2004h")
let &t_EI .= WrapForTmux("\<Esc>[?2004l")

function! XTermPasteBegin()
  set pastetoggle=<Esc>[201~
  set paste
  return ""
endfunction

inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()
" }}}

" Numbers
set number
set numberwidth=5
set relativenumber
set number
nmap <leader>n0 :set relativenumber!<CR>
nmap <leader>nn :set number!<CR>
set ruler
set scroll=4
set scrolloff=15
set textwidth=100
set linebreak

" show command as they are being entered, like in emacs
set showcmd

" windows movement
" Quicker window movement
"nnoremap <C-j> <C-w>j
"nnoremap <C-k> <C-w>k
"nnoremap <C-h> <C-w>h
"nnoremap <C-l> <C-w>l

"Colors
" Prereq export XTERM=xterm-256color,;  install ncurses-term
" The cterm color numbers refer to XTerm colors in 256 color mode.
" Map rgb to cterm colors using <URL:https://gist.github.com/719710>.
" xterm 256 sent using ANSI escape sequence via terminfo file
" guicolor  ---map---> hi-color i.e. 256-color terminal
"    use CSApprox or colorsupport.vim
" Double check color-scheme support hi-color terminal not 16 colors
" Prereqs: install ncurses-term6.1+ TERM=xterm-256, tput color
"
if &term =~ "xterm"
  " 256 colors
  let &t_Co = 256
  set termguicolors
  " true color (i.e. 24bit RGB) escape codes
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  "restore screen after quitting
  let &t_ti = "\<Esc>7\<Esc>[r\<Esc>[?47h"
  let &t_te = "\<Esc>[?47l\<Esc>8"
  let &t_ts = "\<Esc>[k"
  let &t_fe = "\<Esc>G"
  if has("terminfo")
    let &t_Sf = "\<Esc>[3%p1%dm"
    let &t_Sb = "\<Esc>[4%p1%dm"
  else
    let &t_Sf = "\<Esc>[3%dm"
    let &t_Sb = "\<Esc>[4%dm"
  endif
  "distable background color erase when within tmux
  if $TMUX != ""
    set t_ut=
  endif

endif

" send more characters for redraws
set ttyfast
syntax on
set background=dark

"Solarized settings
" set termcolors=256 for 256color. Comment out for TC
" putty=default 256, use patch putty for true color
let g:solarized_termcolors=256
"colorscheme solarized

"Molokai settings
" Set the following for 256color. Comment out for TC
let g:rehash256 = 1
colorscheme molokai

"set cursorline
"set cursorcolumn
"hi CursorLine   cterm=NONE ctermbg=237 ctermfg=NONE guibg=darkred guifg=white
"hi CursorColumn cterm=NONE ctermbg=235 ctermfg=NONE guibg=darkred guifg=white
"
"" use login Shell instead of interactive shell
if executable('zsh')
  set shell=/usr/bin/zsh\ -l
endif

if has("cscope")
  "use both cscope and tag
  set cscopetag
  " add any local cscope db
  if filereadable("cscope.out")
    cs add cscope.out
  endif
  if filereadable ($CSCOPE_DB)
    cs  add  $CSCOPE_DB $CSCOPE_ROOT
    set tags=$CSCOPE_ROOT/tags
  endif
endif
" Show the list for multiple matches
nnoremap <C-]> g<C-]>

" NERDTree
map <leader>ft :NERDTreeToggle<CR>
map <leader>fd :cd %p:h<CR>:pwd<CR>

" Open NERDTree if no file is specified
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

" Open NERDTree if directory is specified
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
" don't show these fil types
let NERDTreeIgnore = ['\.pyc$', '\.pyo$']

"Close vim if NERDTree is the last pane
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
" More space with NERDTree
let g:NERDTreeMinimalUI = 1
let g:NERDTreeMarkBookmarks = 0
let g:NERDTreeAutoDeleteBuffer = 1
let g:NERDTreeStatusLine = -1


" Fugitive
nmap <leader>gs :Gstatus<CR>
nmap <leader>gd :Gdiff<CR>
nmap <leader>gc :Gcommit<CR>
nmap <leader>gb :Gblame<CR>
nmap <leader>gl :Glog<CR>
nmap <leader>gp :Gpush<CR>
nmap <leader>gw :Gwrite<CR>

" janus status line
if janus#is_plugin_enabled('fugitive')
  set statusline+=%{fugitive#statusline()}
endif

" GitGutter
nmap [g  :GitGutterPrevHunk<CR>
nmap ]g  :GitGutterNextHunk<CR>
augroup VimDiff
    autocmd!
    autocmd VimEnter,FilterWritePre * if &diff | GitGutterDisable | endif
augroup END


" ALE settings
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
highlight link ALEWarningSign String
highlight link ALEErrorSign Title
nmap ]w :ALENextWrap<CR>
nmap [w :ALEPreviousWrap<CR>
nmap <Leader>f <Plug>(ale_fix)
let g:ale_lint_on_text_changed = 'never'
" You can disable this option too
" if you don't want linters to run on opening a file
let g:ale_lint_on_enter = 0
" let g:ale_lint_on_text_changed = 'never'
"let g:ale_lint_on_save = 0
augroup VimDiff
    autocmd!
    autocmd VimEnter,FilterWritePre * if &diff | ALEDisable | endif
augroup END

" Airline status line  settings
set laststatus=2
let g:airline_detect_paste=1
let g:airline_theme='cool'
let g:airline_powerline_fonts = 1
let g:airline#extensions#ale#enabled = 1

" SuperTab
let g:SuperTabLongestEnhanced = 1
let g:SuperTabLongestHighlight = 1
au Filetype typescript let b:SuperTabDefaultCompletionType = "<C-x><C-o>"

" CtrlP
"let g:ctrlp_map= '<C-p>'
"let g:ctrlp_cmd = 'CtrlP'

" symtastic
if janus#is_plugin_enabled('syntastic')
  set statusline+=%#warningmsg#
  set statusline+=%{SyntasticStatuslineFlag()}
  set statusline+=%*
endif

if janus#is_plugin_enabled('ale')
  " run linter when files is saved
  let g:ale_lint_on_text_changed = 'never'
  " don't want linters to run on opening a file
  let g:ale_lint_on_enter = 0
endif

"Always use vertical diffs
set diffopt+=vertical
augroup VimDiff
  autocmd!
  if &diff
    set cursorline
    syntax off
    set norelativenumber
    map <leader>1 :diffget LOCAL<CR>
    map <leader>2 :diffget BASE<CR>
    map <leader>3 :diffget REMOTE<CR>
    syntax off
"   hi DiffAdd    ctermfg=233   ctermbg=LightGreen guifg=#003300 guibg=#DDFFDD gui=none cterm=none
"   hi DiffText   ctermfg=233   ctermbg=yellow     guifg=#000033 guibg=#DDDDFF gui=none cterm=none
"   hi DiffChange               ctermbg=white                    guibg=#ececec gui=none cterm=none
  endif
augroup END
if has("patch-8.1.0360")
	set diffopt+=internal,algorithm:patience
endif
" Local config
"if filereadable($HOME . "/.vimrc.project")
  "source ~/.vimrc.project
"endif
"


